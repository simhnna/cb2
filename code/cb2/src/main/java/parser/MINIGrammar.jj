/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = false;
}

PARSER_BEGIN(MINIGrammar)
package parser;
import java.io.FileInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import components.*;
import java.util.ArrayList;
import testsuite.MINIException;
import errorHandling.ErrorHandler;

public class MINIGrammar
{
  public static ArrayList < ClassNode > parse(File in) throws MINIException
  {
    try
    {
      MINIGrammar parser = new MINIGrammar(new FileInputStream(in));
      return parser.file();
    }
    catch (FileNotFoundException e)
    {
      e.printStackTrace();
      return null;
    }
    catch (ParseException e)
    {
      ErrorHandler.handleParseError(in, e.currentToken, e.tokenImage, e.expectedTokenSequences);
      return null;
    }
  }
}

PARSER_END(MINIGrammar)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
| 
  "/*" : IN_MULTI_LINE_COMMENT
}

< IN_SINGLE_LINE_COMMENT >
SPECIAL_TOKEN :
{
  < SINGLE_LINE_COMMENT :
    "\n"
  | "\r"
  | "\r\n" > : DEFAULT
}

< IN_MULTI_LINE_COMMENT >
SPECIAL_TOKEN :
{
  < MULTI_LINE_COMMENT : "*/" > : DEFAULT
}

< IN_SINGLE_LINE_COMMENT, IN_MULTI_LINE_COMMENT >
MORE :
{
  < ~[ ] >
}

< DEFAULT >
TOKEN : /* Reserved keywords and such */
{
  < CLASS : "class" >
| < BRACE_OPEN : "{" >
| < BRACE_CLOSE : "}" >
| < PARAN_OPEN : "(" >
| < PARAN_CLOSE : ")" >
| < ARRAY_DEF : "[]" >
| < THIS : "this" >
| < DOT : "." >
| < COMMA : "," >
| < SEMICOLON : ";" >
| < NULL : "null" >
| < NEW : "new" >
| < RETURN : "return" >
| < VAR : "var" >
| < IF : "if" >
| < ELSE : "else" >
| < WHILE : "while" >
| < ASSIGNMENT : ":=" >
| < MINUS : "-" >
| < NEGATION : "!" >
| < PLUS : "+" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
| < REMAINDER : "%" >
| < EQUAL : "==" >
| < NOTEQUAL : "!=" >
| < LESS_THAN_EQUAL : "<=" >
| < GREATER_THAN_EQUAL : ">=" >
| < LESS_THAN : "<" >
| < GREATER_THAN : ">" >
| < AND : "&&" >
| < OR : "||" >
| < ID : ([ "a"-"z", "A"-"Z" ])+ >
| < INT : ([ "0"-"9" ]) ([ "0"-"9" ])? ([ "0"-"9" ])? ([ "0"-"9" ])? ([ "0"-"9" ])? ([ "0"-"9" ])? ([ "0"-"9" ])? ([ "0"-"9" ])? >
| < BOOL :
    (
      "true"
    | "false"
    ) >
| < STRING :
    "\""
    (
      " "
    | "!"
    | [ "#"-"~" ]
    )*
    "\"" >
| < BAD_TOKEN : ~[ ] >
}

ArrayList < ClassNode > file() :
{
  ArrayList < ClassNode > classes = new ArrayList < ClassNode > ();
  ClassNode cls;
}
{
  (
    cls = mini_class()
    {
      classes.add(cls);
    }
  )*
  < EOF >
  {
    return classes;
  }
}

ClassNode mini_class() :
{
  ClassNode cls = new ClassNode();
  Node classMember;
}
{
  < CLASS >
  < ID > { cls.name = token.image; }
  < BRACE_OPEN >
  (
    classMember = classMember()
    {
      cls.children.add(classMember);
    }
  )*
  < BRACE_CLOSE >
  {
    return cls;
  }
}

Node classMember() :
{
  FieldNode declaration = new FieldNode();
  MethodNode m;
  Token memberName;
  Type type;
}
{
  type = type() memberName = < ID >
  (
    < SEMICOLON >
    {
      declaration.name = memberName;
      declaration.type = type;
      
      return declaration;
    }
  | m = method()
  {
      m.name = memberName;
      m.returnType = type;
      return m;
    }
  )
}


MethodNode method() :
{
  MethodNode n = new MethodNode();
  BlockNode block;
}
{
  n.arguments = signature() n.body = blockStatement()
  {
    return n;
  }
}

Type type() :
{
  Type t = new Type();
}
{
  t.baseType = < ID > (< ARRAY_DEF > { t.arrayDimensions++; })*
  {
    return t;
  }
}

ArrayList < NamedType > signature() :
{
  ArrayList < NamedType > arguments = new ArrayList < NamedType > ();
  NamedType nT = new NamedType();
}
{
  < PARAN_OPEN >
  (
    nT.type = type()
    nT.name=< ID >
	{
      arguments.add(nT);
    }
    (
      < COMMA >
      {
        nT = new NamedType();
      }
      nT.type = type()
      nT.name = < ID >
      {
        arguments.add(nT);
      }
    )*
    
  )?
  < PARAN_CLOSE >
  {
    return arguments;
  }
}

StatementNode statement() :
{StatementNode s = null;}
{
  (    s = blockStatement()
  | s = ifStatement()
  | s = whileStatement()
  | s = returnStatement()
  | expression()
  (
    < SEMICOLON >
    | < ASSIGNMENT > expression() < SEMICOLON >
  ) 
  | < VAR > < ID > < ASSIGNMENT > expression() < SEMICOLON >
  )
  {
    return s;
  }
}

BlockNode blockStatement() :
{
  BlockNode block = new BlockNode();
  StatementNode statement;
}
{
  < BRACE_OPEN >
  (
    statement=statement()
    {
      block.children.add(statement);
    }
  )*
  < BRACE_CLOSE >
  {
    return block;
  }
}

IfNode ifStatement() :
{
  IfNode n = new IfNode();
}
{
  < IF > < PARAN_OPEN > n.condition = expression()
  < PARAN_CLOSE > n.first = blockStatement()
  (
    < ELSE > n.second = blockStatement()
  )?
  {
    return n;
  }
}

WhileNode whileStatement() :
{
  WhileNode n = new WhileNode();
}
{
  < WHILE > < PARAN_OPEN > n.condition = expression()
  < PARAN_CLOSE > n.body = blockStatement()
  {
    return n;
  }
}

ReturnNode returnStatement() :
{
  ReturnNode n = new ReturnNode();
}
{
  < RETURN > n.value = expression() < SEMICOLON >
  {
    return n;
  }
}

ExpressionNode expression() :
{ExpressionNode n = null;}
{
  (    unaryOperator() expression()
  | atomicExpression() (expression_suffix())?
  )
  {
    return n;
  }
}

void expression_suffix() :
{}
{
	binaryOperator() expression()
	| < DOT > < ID > (argumentList())? (expression_suffix())?
}
void unaryOperator() :
{}
{
  < MINUS >
| < NEGATION >
}

void binaryOperator() :
{}
{
  < PLUS >
| < MINUS >
| < MULTIPLY >
| < DIVIDE >
| < REMAINDER >
| < EQUAL >
| < NOTEQUAL >
| < LESS_THAN_EQUAL >
| < GREATER_THAN_EQUAL >
| < LESS_THAN >
| < GREATER_THAN >
| < AND >
| < OR >
}

void argumentList() :
{}
{
  < PARAN_OPEN >
  (
    expression()
    (
      < COMMA > expression()
    )*
  )?
  < PARAN_CLOSE >
}

void atomicExpression() :
{}
{
  < ID >
  ( argumentList())?
| < THIS >
| < STRING >
| < INT >
| < BOOL >
| nullExpression()
| newExpression()
| < PARAN_OPEN > expression() < PARAN_CLOSE >
}

void nullExpression() :
{}
{
  < NULL > < LESS_THAN > type() < GREATER_THAN >
}

void newExpression() :
{}
{
  < NEW > < LESS_THAN > type()
  (
    < COMMA >
    (
      < INT >
    | < ID >
    )
  )*
  < GREATER_THAN >
}